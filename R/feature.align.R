to_attach <- function(pick, number_of_experiments, use = "sum") {
    strengths <- rep(0, number_of_experiments)
    if (is.null(nrow(pick))) {
        strengths[pick[6]] <- pick[5]
        return(c(pick[1], pick[2], pick[1], pick[1], strengths))
    } else {
        for (i in seq_along(strengths)) {
            if (use == "sum")
                strengths[i] <- sum(pick[pick[, 6] == i, 5])
            if (use == "median")
                strengths[i] <- median(pick[pick[, 6] == i, 5])
        }
        return(c(mean(pick[, 1]), mean(pick[, 2]), min(pick[, 1]),
            max(pick[, 1]), strengths))
    }
}

# returns a list of aligned features and original peak times
feature.align <- function(features,
                          min.exp = 2,
                          mz.tol = NA,
                          chr.tol = NA,
                          find.tol.max.d = 1e-4,
                          max.align.mz.diff = 0.01,
                          do.plot = TRUE,
                          rt_colname = "pos") {
    if (do.plot) {
        par(mfrow = c(3, 2))
        plot(c(-1, 1), c(-1, 1), type = "n", xlab = "",
             ylab = "", main = "", axes = FALSE)
        text(x = 0, y = 0, "Feature alignment", cex = 2)
        plot(c(-1, 1), c(-1, 1), type = "n", xlab = "", 
             ylab = "", main = "", axes = FALSE)
    }
        
    number_of_experiments <- nrow(summary(features))
    if (number_of_experiments > 1)
    {
        values <- get_feature_values(features, rt_colname)
        mz_values <- values$mz
        chr <- values$chr
        lab <- values$lab
        
        # sort values
        o <- order(mz_values, chr)
        mz_values <- mz_values[o]
        chr <- chr[o]
        lab <- lab[o]
        l <- length(mz_values)
        
        if (is.na(mz.tol)) {
            mz.tol <- find.tol(mz_values, uppermost = find.tol.max.d, do.plot = do.plot)
            if (length(mz.tol) == 0) {
                mz.tol <- 1e-5
                warning("Automatic tolerance finding failed, 10 ppm was assigned. 
                        May need to manually assign alignment mz tolerance level.")
            }
        } else if (do.plot) {
            plot(c(-1, 1), c(-1, 1), type = "n", xlab = "", ylab = "",
                main = "alignment m/z tolerance level given", axes = FALSE)
            text(x = 0, y = 0, mz.tol, cex = 1.2)
        }
        
        if (!is.na(chr.tol) && do.plot) {
            plot(c(-1, 1), c(-1, 1), type = "n", xlab = "", ylab = "",
                 main = "retention time \n tolerance level given", axes = FALSE)
            text(x = 0, y = 0, chr.tol, cex = 1.2)
        }
        
        all.ft <- find.tol.time(mz_values,
                                chr,
                                lab,
                                number_of_experiments = number_of_experiments,
                                mz.tol = mz.tol,
                                chr.tol = chr.tol,
                                max.mz.diff = max.align.mz.diff,
                                do.plot = do.plot)
        chr.tol <- all.ft$chr.tol
        
        message("**** performing feature alignment ****")
        message(paste("m/z tolerance level: ", mz.tol))
        message(paste("time tolerance level:", chr.tol))
        
        aligned.ftrs <- pk.times <- rep(0, 4 + number_of_experiments)
        mz.sd.rec <- 0
        
        labels <- unique(all.ft$grps)
        area <- grps <- mz_values
        
        sizes <- c(0, cumsum(sapply(features, nrow)))
        for (i in 1:number_of_experiments) {
            this <- features[[i]]
            sel <- which(all.ft$lab == i)
            that <- cbind(all.ft$mz[sel], all.ft$chr[sel], all.ft$grps[sel])
            this <- this[order(this[, 1], this[, 2]),]
            that <- that[order(that[, 1], that[, 2]),]
            
            mz_values[(sizes[i] + 1):sizes[i + 1]] <- this[, 1]
            chr[(sizes[i] + 1):sizes[i + 1]] <- this[, 2]
            area[(sizes[i] + 1):sizes[i + 1]] <- this[, 5]
            grps[(sizes[i] + 1):sizes[i + 1]] <- that[, 3]
            lab[(sizes[i] + 1):sizes[i + 1]] <- i
        }
        
        ttt <- table(all.ft$grps)
        curr.row <- sum(ttt >= min.exp) * 3
        mz.sd.rec <- rep(0, curr.row)
        curr.row <- 1
        
        sel.labels <- as.numeric(names(ttt)[ttt >= min.exp])
        
        aligned.ftrs <-
            foreach(i = seq_along(sel.labels), .combine = rbind) %dopar% {
                if (i %% 100 == 0) {
                    gc()
                }
                this.return <- NULL
                sel <- which(grps == sel.labels[i])

                if (length(sel) > 1) {
                    this <- cbind(mz_values[sel], chr[sel], chr[sel], 
                                  chr[sel], area[sel], lab[sel])
                    if (length(unique(this[, 6])) >= min.exp) {
                        this.den <- density(this[, 1], bw = mz.tol * median(this[, 1]))
                        turns <- find.turn.point(this.den$y)
                        pks <- this.den$x[turns$pks]
                        vlys <- this.den$x[turns$vlys]
                        for (j in seq_along(pks)) {
                            this.lower <- max(vlys[vlys < pks[j]])
                            this.upper <- min(vlys[vlys > pks[j]])
                            this.sel <- which(this[, 1] > this.lower & this[, 1] <= this.upper)
                            that <- this[this.sel, ]
                            if (!is.null(nrow(that))) {
                                if (length(unique(that[, 6])) >= min.exp) {
                                    that.den <- density(that[, 2], bw = chr.tol / 1.414)
                                    that.turns <- find.turn.point(that.den$y)
                                    that.pks <- that.den$x[that.turns$pks]
                                    that.vlys <- that.den$x[that.turns$vlys]
                                    for (k in seq_along(that.pks)) {
                                        that.lower <- max(that.vlys[that.vlys < that.pks[k]])
                                        that.upper <- min(that.vlys[that.vlys > that.pks[k]])
                                        thee <- that[that[, 2] > that.lower & that[, 2] <= that.upper, ]
                                        if (!is.null(nrow(thee))) {
                                            if (length(unique(thee[, 6])) >= min.exp) {
                                                this.return <-
                                                    c(to_attach(thee, number_of_experiments, use = "sum"),
                                                      to_attach(thee[, c(1, 2, 3, 4, 2, 6)], number_of_experiments, use = "median"),
                                                      sd(thee[, 1], na.rm = TRUE)
                                                     )
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (min.exp == 1) {
                        thee <- c(mz_values[sel], chr[sel], chr[sel], chr[sel], area[sel], lab[sel])
                        this.return <- c(to_attach(thee, number_of_experiments, use = "sum"),
                                         to_attach(thee[c(1, 2, 3, 4, 2, 6)], number_of_experiments, use = "median"),
                                         NA
                                        )
                    }
                }
                this.return
            }
        
        pk.times <- aligned.ftrs[, (5 + number_of_experiments):(2 * (4 + number_of_experiments))]
        mz.sd.rec <- aligned.ftrs[, ncol(aligned.ftrs)]
        aligned.ftrs <- aligned.ftrs[, 1:(4 + number_of_experiments)]
        
        colnames(aligned.ftrs) <-
            colnames(pk.times) <-
            c("mz", "time", "mz.min", "mz.max", paste("exp", 1:number_of_experiments))
        
        rec <- new("list")
        rec$aligned.ftrs <- aligned.ftrs
        rec$pk.times <- pk.times
        rec$mz.tol <- mz.tol
        rec$chr.tol <- chr.tol
        
        if (do.plot) {
            hist(mz.sd.rec, xlab = "m/z SD", ylab = "Frequency",
                 main = "m/z SD distribution")
            hist(apply(pk.times[, -1:-4], 1, sd, na.rm = TRUE), 
                 xlab = "Retention time SD", ylab = "Frequency",
                 main = "Retention time SD distribution")
        }
        
        return(rec)
    } else {
        message("There is but one experiment. What are you trying to align?")
        return(0)
    }
}
